<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 在 UEFI 机器上修复了 Arch Linux 和 Windows 8 的双引导 · Bach is coding</title><meta name="description" content="在 UEFI 机器上修复了 Arch Linux 和 Windows 8 的双引导 - winiex"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">HOME</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/winiex" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">在 UEFI 机器上修复了 Arch Linux 和 Windows 8 的双引导</h1><div class="post-info">Jun 10, 2013</div><div class="post-content"><p>是的，我重装系统了。前天晚上，不知道从哪里来的好奇心的驱使，我在终端上运行了许多 Archer 又爱又恨的“终极命令”：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -Syu</span><br></pre></td></tr></table></figure>
<p>没错，就是这句传说中的系统升级命令。说这句命令是“终极命令”（有人说，“终极命令”不是 <strong>sudo rm / -rf</strong> 吗？），主要是因为对于菜鸟而言，如果两次升级之间时间间隔过大，你将很有可能遇到各种奇怪的问题。我比较幸运，这次升级一共下载了 1G 左右的软件包，更新完毕后并没有很多大问题出现。最终导致我选择下下策“祭出大杀器重装系统”的原因是，GNOME 更新到了 3.8.1。</p>
<a id="more"></a>
<h2 id="是-GNOME-3-8-1-让我不再相信爱情"><a href="#是-GNOME-3-8-1-让我不再相信爱情" class="headerlink" title="是 GNOME 3.8.1 让我不再相信爱情"></a>是 GNOME 3.8.1 让我不再相信爱情</h2><p>更新到了 GNOME 3.8.1 之后，我遇到了这些自己解决不了的问题（水平真的有限啊）：</p>
<ol>
<li>无论如何都不能唤出 Fcitx 输入法的窗口，但是它的 dbus daemon 却一直成功地自启动着</li>
<li>GNOME 3.8.1 中包含的 gonome-terminal 3.8.1 竟然<strong><a href="https://bbs.archlinux.org/viewtopic.php?pid=1264078" target="_blank" rel="external">不支持透明背景了</a></strong>（这个我真的解决不了了）。</li>
<li>桌面系统经常会发生莫名其妙的崩溃，就像下面这张图一样：</li>
</ol>
<img src="http://o9fv3ui6e.bkt.clouddn.com/e332aa4c-3ca6-11e6-9692-a74eb999edcd.png" class="center" width="600">
<p>对于 Fcitx 的问题，我寻找了包含配置、Fcitx 版本在内许多原因，最终把问题锁定在了 GNOME 3.8.1 上。于是，我安装了 KDE 桌面（感谢学校教育网的神速）做测试，果然，Fcitx 工作正常了。对于 gnome-terminal 3.8.1 不支持透明背景的问题，或许我可以换用 <a href="http://software.schmorp.de/pkg/rxvt-unicode.html" target="_blank" rel="external">urxvt</a> 这样经典的 terminal emulator 来“弥补遗憾”，但是终究觉得好像人生中缺少了什么 :(。对于最后一个问题的话，我想了好久，解决方案就是抛弃掉 GNOME，转向 KDE（其实是因为各种不爽，蓄谋已久了）。</p>
<p>可是啊，终究我还是一个对自己的计算机操作系统软件包有洁癖的家伙，如果现在中途转向 KDE，总有一种系统不“干净”的感觉（好吧，其实我知道很多朋友是同时安装了 GNOME 和 KDE 的）。所以啊，我就纠结地重装系统了。</p>
<h2 id="帮助我解决问题的一些资料"><a href="#帮助我解决问题的一些资料" class="headerlink" title="帮助我解决问题的一些资料"></a>帮助我解决问题的一些资料</h2><p>因为已经折腾过很多遍 Arch Linux 的安装了，这次按照 <a href="https://wiki.archlinux.org/index.php/Beginners%27_Guide/Installation_\(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87\" target="_blank" rel="external">Arch Linux Beginners’ Guide</a>)安装系统可谓驾轻路熟（这句话有避开文档中小陷阱的意思 :)）。最后的问题，却是出在了系统引导上面——或者更直接点说，问题出在了我的电脑是基于 UEFI 主板之上的这个事实。</p>
<p>记得最开始，我把电脑拿回来开始要装 Arch Linux，并且发现它是 UEFI 的主板时，曾经纠结了很久。问一位玩过很久 Arch Linux 的朋友该怎么办，他也是告诉我“祝你好运”。上次安装成功，完全是瞎猫碰上死耗子了。这次重新安装系统，我决定一定要把安装的过程以及大略的原理进行理解，这样才好。</p>
<p>最后，还是 Arch Linux 的 Wiki 和讨论组帮了我的大忙。我发现了下面这些很有价值的资源：</p>
<ol>
<li>关于 UEFI 的基础知识介绍的 <a href="https://wiki.archlinux.org/index.php/Unified_Extensible_Firmware_Interface" target="_blank" rel="external">Wiki</a>。在这篇 Wiki 里面，我了解了 UEFI 的来龙去脉、产生原因以及初级知识。</li>
<li>和 UEFI 息息相关的 GPT 分区格式的介绍 <a href="https://wiki.archlinux.org/index.php/GUID_Partition_Table" target="_blank" rel="external">Wiki</a>。GPT 分区格式我们很熟悉的 <a href="http://en.wikipedia.org/wiki/Master_boot_record" target="_blank" rel="external">MBR</a> 有很大的不同，刚开始我不了解它们之间的区别，犯了很多错误。</li>
<li>介绍在 UEFI 机器上安装 Grub2 从而完成多重引导的 <a href="https://wiki.archlinux.org/index.php/GRUB#UEFI_systems_2" target="_blank" rel="external">Wiki</a>。虽说，还有安装上更为简单的 <a href="http://www.rodsbooks.com/refind/" target="_blank" rel="external">rEFInd</a> 可以来做系统引导，但是我对 Grub2 有怀旧情节，所以最后还是选择了 Grub2。</li>
<li>还有讨论组上非常有价值的<a href="https://bbs.archlinux.org/viewtopic.php?id=145899" target="_blank" rel="external">一篇帖子</a>。在这篇帖子的 6 楼，一位大牛介绍了正确安装的步骤，我从这里获得了很多启发。在此必须表示我的谢意啊！</li>
<li>阮一峰前辈写过一篇有关<a href="http://www.ruanyifeng.com/blog/2013/02/booting.html" target="_blank" rel="external">计算机启动</a>的相关知识介绍的博文，我看了之后对以前使用的 MBR 启动方式有了更深入的了解。</li>
</ol>
<p>上次安装过程中，我直接寻找到成功案例，然后按照他们的流程一路做下来，并没有弄懂所有的东西。这次，通过这些资料，我对 UEFI 相关的问题又有了进一步的理解。</p>
<h2 id="修复引导的过程"><a href="#修复引导的过程" class="headerlink" title="修复引导的过程"></a>修复引导的过程</h2><p>好吧，闲话了两小结（喂…），下面就说一下我修复引导的过程吧。</p>
<p>首先，我们必须得为 Grub2 在系统磁盘上创建一个保留分区，Grub2 会在系统启动的过程中利用这个分区完成一些工作。在 Wiki 中，有介绍分配该分区的方法的<a href="https://wiki.archlinux.org/index.php/GRUB#GUID_Partition_Table_.28GPT.29_specific_instructions" target="_blank" rel="external">文章</a>，所以我就不再赘述了。最终，我的 Grub2 保留分区便是下图中的 1M 大小的 sda1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ lsblk</span><br><span class="line">NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda      8:0    0 931.5G  0 disk</span><br><span class="line">├─sda1   8:1    0     1M  0 part</span><br><span class="line">├─sda2   8:2    0   512M  0 part /boot/efi</span><br><span class="line">├─sda3   8:3    0   128M  0 part</span><br><span class="line">├─sda4   8:4    0    60G  0 part</span><br><span class="line">├─sda5   8:5    0   621G  0 part /home/winiex/mnt/alpha</span><br><span class="line">└─sda6   8:6    0 249.9G  0 part /</span><br><span class="line">sr0     11:0    1  1024M  0 rom</span><br></pre></td></tr></table></figure>
<p>在划分了 Grub2 的保留分区后，我们接下来要做的工作是为 Grub2 的 UEFI 启动程序划分一个至少 512M 的分区，从而保存相关的 UEFI 启动程序。在系统启动的时候，UEFI 管理程序会寻找到这个启动程序，从而将系统引导的工作转交给它。</p>
<p>这里存在一个技巧。因为，我想要安装的是 Windows 8 和 Arch Linux 双启动系统，所以理论上来讲，给它们都分配一个启动程序所在的分区是比较科学的。但是，这样的分区我觉得不“优雅”。再加上根据我的研究，UEFI 启动程序所占用的空间并不是很大，所以在一个 512M 大小的分区内同时保存 Windows 8 和 Arch Linux 的 UEFI 启动程序是不会存在问题的。</p>
<p>所以，我在安装 Arch Linux 之前便安装了 Windows 8，这样 Windows 8 的安装程序会在硬盘中自动分配一个 512M 大小的分区存放它的 UEFI 启动程序，并且这个启动程序是放在一个单独的文件夹里面的。在这之后，我只需要在这个分区里面新建一个文件夹，然后将 Arch Linux 要使用的 Grub2 引导程序安装到这里，最后在 UEFI 管理程序中把它的项目提前，这样就可以开机使用 Grub2 来引导系统了。</p>
<p>我想你已经发现了，在刚才的那幅 lsblk 结果图中，大小为 512M 的 sda2 便是我存放 UEFI 启动引导程序的分区。在 Arch Linux 中，我将它挂载到了 /boot/efi 下。在这个目录下的文件组织形式是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ tree /boot/efi/ -L 3</span><br><span class="line">/boot/efi/</span><br><span class="line">└── EFI</span><br><span class="line">    ├── arch_grub</span><br><span class="line">    │   └── grubx64.efi</span><br><span class="line">    ├── Boot</span><br><span class="line">    │   └── bootx64.efi</span><br><span class="line">    └── Microsoft</span><br><span class="line">        └── Boot</span><br><span class="line"></span><br><span class="line">5 directories, 2 files</span><br></pre></td></tr></table></figure>
<p>没错，你会发现，我现在的 UEFI 启动程序组织方式就是和我方才描述的方式是一样的。当然，如果你并不想像我这样让两个启动程序存在于一个分区内，你也可以自行重新分一个区来存放 Grub2 的启动程序，相关的资料可以在<a href="https://wiki.archlinux.org/index.php/Unified_Extensible_Firmware_Interface#EFI_System_Partition" target="_blank" rel="external">这里</a>找到。无论如何，最后，将这个准备好的分区给挂载到 /boot/efi 上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /boot/efi #一般这个目录是不存在的</span><br><span class="line">sudo mount /dev/sdXY /boot/efi #X Y 根据你磁盘的情况进行改变</span><br></pre></td></tr></table></figure></p>
<p>完成了这一步之后，我们就可以开始安装 Grub2 提供的 UEFI 启动程序了。安装过程比较简单，在 Wiki 上也存在<a href="https://wiki.archlinux.org/index.php/GRUB#UEFI_systems_2" target="_blank" rel="external">文章</a>进行介绍，所以我就不再赘述了。需要提醒的是，一定要根据你自己机器的情况，安装相应的 Grub2 程序包。</p>
<p>安装到了这里，所有的工作很可能就已经完成了。你大可以重新开机，然后查看是否安装成功了。不过，在这之前，你最好进入<a href="https://wiki.archlinux.org/index.php/Unified_Extensible_Firmware_Interface#Important_UEFI_Shell_Commands" target="_blank" rel="external">这个页面</a>把一些重要的 UEFI Shell 命令记录下来，以备不时之需。</p>
<p>好，重启系统，如果发现系统的 Boot 设置选项中，多了 Arch Linux 的 Grub2 的选项，那代表你很可能已经成功了，恭喜！而如果你没有发现任何变化，直接就进入 Windows 8 了，那很可能就是因为，安装 Grub2 的过程中，没有成功地自动添加 Boot Entry 到 UEFI 系统管理程序中。这个时候，就得我们手动添加 entry 到系统中去了——而刚才我们记录下来的 UEFI Shell 就派上了用场。那些命令，你只需要按照自己的路径来改动一下再执行即可。更大的问题是，我们在哪里可以使用到 UEFI Shell 呢？这个问题我并没有深入研究过，但是，只要你的安装光盘是成功地以 UEFI 的方式启动了的话，就可以进入 UEFI Shell 来使用相关命令——我使用的 Cinnarch 发行版就是可以的。</p>
<p>等你将 Entry 添加完毕后，Grub2 就可以正常使用了。</p>
<p>最后，我们就只剩下一个事情要做了：用 Grub2 来引导 Windows 8 系统的启动。这个无论是手动修改 grub.cfg 还是自动的 os-prober，只要管用就行。使用搜索引擎搜索一下的话肯定可以找到很多资料，所以我也就不多说了 :)。</p>
<p>嗯，大概的过程，就是这样的。</p>
<h2 id="最后我还有一句话"><a href="#最后我还有一句话" class="headerlink" title="最后我还有一句话"></a>最后我还有一句话</h2><p>现在，我使用 KDE，妈妈再也不用担心我的系统不稳定了。</p>
</div></article></div></section><footer><div class="paginator"><a href="/2014/10/16/bash-function-to-get-gitignore-easily/" class="prev">PREV</a><a href="/2013/05/10/what-personalities-should-multi-field-experts-have/" class="next">NEXT</a></div><div data-thread-key="2013/06/10/fix-arch-linux-windows-dual-boot-on-a-machine-with-uefi/" data-title="在 UEFI 机器上修复了 Arch Linux 和 Windows 8 的双引导" data-url="http://bachiscoding.com/2013/06/10/fix-arch-linux-windows-dual-boot-on-a-machine-with-uefi/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"bachiscoding"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2015 - 2016 <a href="http://bachiscoding.com">winiex</a>, unless otherwise noted.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>