<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Bach is coding</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link active">HOME</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/winiex" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/07/07/octotree-plugin-for-github-in-chrome/" class="post-title-link">Octotree：在 Chrome 里用树状的方式浏览 Github 的文件</a></h2><div class="post-info">Jul 7, 2016</div><div class="post-content"><p>一直以来，Github 的文件浏览功能都不能够满足我的日常使用需求，直到今天我发现了 <a href="https://chrome.google.com/webstore/detail/octotree/bkhaagjahfmjljalopjnoealnfndnagc">Octotree</a> 这款 Chrome 浏览器插件。这款插件能够在 Github 的项目页面的左边提供一个树形菜单，让用户能够更方便地浏览项目内的文件，从而避免每次浏览都需要刷新整个页面。</p></div><a href="/2016/07/07/octotree-plugin-for-github-in-chrome/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/06/10/configuration-in-hadoop/" class="post-title-link">Hadoop 中的 Configuration</a></h2><div class="post-info">Jun 10, 2016</div><div class="post-content"><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>从这篇文章开始，我将把自己对 Hadoop 系统的一些学习经验整理成文章分享出来，算是对自己学习过程的梳理和知识的分享。我主要会从源代码的角度去探索 Hadoop 中的各个组件的技术细节，使用的是 <a href="https://github.com/apache/hadoop/tree/branch-2.7.2">2.7.2</a> 的源代码。</p>
<p>一个成熟的软件系统必备的组件之一就是配置系统。配置系统负责将纷繁复杂的配置项按照一定的既定规则管理起来，从而让系统的其他组件不必重复处理类似于配置加载、配置 Override、扩展配置字段中的引用符号等细节。我所熟悉的 Tornado、Django、Laravel 等 Web 框架都会有一套自己严格规定的配置系统；这也引导了我平时新开一个项目的时候，第一时间着手实现的就是配置管理模块——这是因为我相信配置管理被成熟地实现会避免一系列问题（尤其是部署过程中的）。久而久之，在 Python Web 开发领域我已经有了自己的一套「最佳实践」——配置存储于 JSON、YAML 文件，使用脚本将内容映射为 Python 模块对象，使用时直接导入变量即可，而配置文件本身本地、开发机与线上各自保存一份，与代码部署过程分离（这样可以避免本地的、开发机器上的或生产环境的配置文件随频率更高的代码部署流程误部署）。大型系统甚至会衍生出自己的配置管理服务（例如<a href="http://www.infoq.com/cn/articles/weibao-config-service-practice">微博的实践</a>）来应对日益复杂的配置管理工作，而开源社区也贡献了 <a href="https://coreos.com/etcd/">etcd</a> 这种优秀的解决方案。</p>
<p>Hadoop 中的配置系统和我前述的自己的「最佳实践」的做法类似——数据主要存储于 XML 文件中，由 <a href="https://hadoop.apache.org/docs/r2.7.2/api/org/apache/hadoop/conf/Configuration.html">org.hadoop.conf.Configuration</a> 类负责配置加载、Override、字段扩展等工作，每个 Hadoop 组件在启动后都会拥有自己的 Configuration 实例（最常见的就是 MapReduce 2 程序中你在 job 代码的 main 方法里 new 的那个），需要获取或者设置某个配置字段时只需要调用相应的方法即可。这种做法在 Java 社区比较常见，Tomcat、Spring 等知名 Java 项目都采用了类似的方案。</p></div><a href="/2016/06/10/configuration-in-hadoop/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/11/24/annotations-on-paper-trail-columnar-storage/" class="post-title-link">【译注】Columnar Storage - 列式存储</a></h2><div class="post-info">Nov 24, 2015</div><div class="post-content"><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>最近一段时间，我主要在构建公司的数据决策系统。依照规划，公司内部打算在 Hadoop 集群上借助 Impala 来实现一个近实时化的 SQL 执行环境，让它来提供数据查询接口给前端报表系统。这套系统的基础思想来自 Google 于 2010 年发表的一篇 paper：<a href="http://research.google.com/pubs/pub36632.html">Dremel - Interactive Analysis of Web-Scale Datasets</a>。</p>
<p>要降低查询的延时，涉及到了一系列的优化手段，其中列式存储的方案便是其一。这篇文章便是我在学习的过程中看到的，质量上乘，便翻译下来。</p>
<blockquote>
<p>Origin: <a href="http://the-paper-trail.org/blog/columnar-storage/">http://the-paper-trail.org/blog/columnar-storage/</a></p>
</blockquote>
<p>原文地址：<a href="http://the-paper-trail.org/blog/columnar-storage/">http://the-paper-trail.org/blog/columnar-storage/</a></p></div><a href="/2015/11/24/annotations-on-paper-trail-columnar-storage/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2014/12/27/let-us-talk-about-objc-properties/" class="post-title-link">让我们来谈谈 @property</a></h2><div class="post-info">Dec 27, 2014</div><div class="post-content"><p>写了一些 iOS 平台上的代码后，我发现自己对于 @property 这个 Objective-C 中很重要、最经常使用的特性不是很熟悉，而这也影响到了我的开发质量。特别是，@property 存在许多选项，nonatomic、weak、assign、copy 等等一系列配置，我弄了很久还是不能分辨清楚，看到开源项目中的用法也会搞不清楚原由，更别提合理地使用。所以我决定好好地研究一下这个问题。</p></div><a href="/2014/12/27/let-us-talk-about-objc-properties/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2014/12/26/some-thoughts-on-quicksort/" class="post-title-link">关于快速排序算法的一些想法</a></h2><div class="post-info">Dec 26, 2014</div><div class="post-content"><p>作为一个处理问题的很基础的手段，排序在计算机科学的各个方面广泛应用着——例如在查找算法中，如果我们面对的是有序列的话，那么用二分查找我们就倍感顺利、快速，而要获得有序列，首先就得对待查找序列进行排序；又例如，在操作系统的内存管理机制中，内存分配存在<a href="http://thumbsup2life.blogspot.com/2011/02/best-fit-first-fit-and-worst-fit-memory.html">许多策略</a>，其中一种被称作 First Fit——遍历可用内存，找到第一个大于等于所需内存大小的内存块，在这块内存块中分配所需内存供使用——而为了让遍历的过程更为快速，或者说降低 First Fit 分配策略实现的时间复杂度，我们可以维护一个按可用内存块大小进行降序排序的内存块索引表，当我们分配内存时便总是可以在索引表中第一位得到最大的可用内存块的地址，从而减少遍历时间，而为了维护这个降序的可用内存索引表，在内存的分配的过程中就必须对内存索引表进行以内存大小为主键的排序操作；再例如，在一些 web 后端程序的页面 cache 机制实现中，我们会按照自己的计算标准对各个页面记录下热度，进而让热度高的页面能够被优先缓存到资源有限的 cache 服务器内存中，为了维护这个表，我们就必须定期对该表进行以页面热度为主键进行降序排序操作。类似的例子，常见的、不常见的还有很多。可以说，排序基本上被应用在软件开发的各个层级、领域。</p></div><a href="/2014/12/26/some-thoughts-on-quicksort/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2014/12/15/when-will-layoutsubviews-be-invoked/" class="post-title-link">关于 UIView 的 layoutSubviews 方法</a></h2><div class="post-info">Dec 15, 2014</div><div class="post-content"><p>UIKit 的 UIView 是一个非常重要的类，几乎每个尝试 iOS 开发的程序员都会用到它。UIView 本身实现了 <a href="http://en.wikipedia.org/wiki/Composite_pattern">Composite Pattern</a>，所以一个应用的界面最终可以由一群树状组合的 UIView 来组合而成——在这棵 UIView 树的最顶部，是继承于 UIView 的 UIWindow 实例，然后是由 UIWindow 实例保有的 rootViewController 的根 UIView 实例，然后是在该 UIView 实例上的各种各样的子节点 UIView。</p></div><a href="/2014/12/15/when-will-layoutsubviews-be-invoked/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2014/11/11/relationship-between-anchor-point-and-position-property-of-calayer/" class="post-title-link">CALayer 的 position 属性与 anchorPoint 属性间的关系</a></h2><div class="post-info">Nov 11, 2014</div><div class="post-content"><p>因为最近在制作自己的独立产品，我学习了一些 iOS 平台的知识。在我的产品界面中，有一个侧边栏需要单独绘制自定义外观，所以这几天我就研究了一下 UIView 的绘制机理以及 Core Animation 中 CALayer 的相关的知识。在 CALayer 中有一个我比较困惑的地方：position 和 anchorPoint 之间的关系，以及它们对于动画、UIView 绘制的过程会作出何种影响。在看了一遍官方文档，搜索了一些相关博客文章、帖子后，我有了较为完整的理解。</p></div><a href="/2014/11/11/relationship-between-anchor-point-and-position-property-of-calayer/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2014/10/21/the-way-of-becoming-a-newbie-designer/" class="post-title-link">成为一个新手设计师</a></h2><div class="post-info">Oct 21, 2014</div><div class="post-content"><p>这篇博客是我针对知乎上“<a href="http://www.zhihu.com/question/22948728">高三学生自学UI或交互设计需要怎么做？</a>”这个问题给出的<a href="http://www.zhihu.com/question/22948728/answer/32234209">答案</a>，算是对自己这段时间瞎玩设计的一个小结吧 :)。</p>
<p>如果你是以实作而非理论为目标，而且愿意从 UI 设计入门的话，我的建议如下：</p></div><a href="/2014/10/21/the-way-of-becoming-a-newbie-designer/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2014/10/19/microsoft-natural-ergonomic-keyboard-4000-zoom-to-scroll-on-mac-os-x/" class="post-title-link">在 Mac OS X 上修改 Microsoft Natural Ergonomic 4000 的 Zoom 键为 Scroll 键</a></h2><div class="post-info">Oct 19, 2014</div><div class="post-content"><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>因为和 Microsoft Natural Ergonomic 4000 配套使用的驱动 IntelliType Pro for Mac 是<strong>微软开发的 Mac OS X 驱动程序</strong>，所以在功能上它是有一定的残疾度的——譬如它不能在开机的时候自动加载用户配置（= =），进而在开机后你无法使用设置好的相关驱动配置。你有三个选择：</p>
<ol>
<li>删掉它。</li>
<li>每次开机的时候都点击一次配置程序（系统偏好设置 &gt; Microsoft Keyboard）从而加载配置。</li>
<li>使用 Launchd 在开机的时候，每次都执行一次 “open /Library/PreferencePanes/Microsoft\ Keyboard.prefPane” 命令从而加载相关配置。</li>
</ol></div><a href="/2014/10/19/microsoft-natural-ergonomic-keyboard-4000-zoom-to-scroll-on-mac-os-x/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2014/10/16/bash-function-to-get-gitignore-easily/" class="post-title-link">用于获取 .gitignore 的 Bash 命令</a></h2><div class="post-info">Oct 16, 2014</div><div class="post-content"><p>新开的项目，按照常理出牌的话，一般都是需要使用 Git 来进行版本控制，以免代码数据丢失的。而使用 Git 的时候，按照常理出牌的话，一般是要给项目添加一个 <a href="http://git-scm.com/docs/gitignore">.gitignore 文件</a>，从而使那些不该纳入版本控制的文件能够被 Git 排除在外的。例如，使用 Python 开发的项目一般都需要将 .pyc 文件排除在外；使用编译型语言来开发的项目，一般会将可执行程序、中间编译结果文件等排除在外。</p>
<p>不加 .gitignore 的话，一般而言后果是很严重的。之前我刚开始接触 Python 开发的时候，就由于没有考虑这些，最后将所有 .pyc 文件都纳入了版本管理，到了后来发现了这个问题后，才不得不手动删除所有目录下的 .pyc 文件：</p></div><a href="/2014/10/16/bash-function-to-get-gitignore-easily/" class="read-more">...more</a></article></li></ul></section><footer><div class="paginator"><a href="/page/2/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2016 <a href="http://bachiscoding.com">winiex</a>, unless otherwise noted.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>