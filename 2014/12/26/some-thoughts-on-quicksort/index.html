<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 关于快速排序算法的一些想法 · Bach is coding</title><meta name="description" content="关于快速排序算法的一些想法 - winiex"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/winiex" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">关于快速排序算法的一些想法</h1><div class="post-info">Dec 26, 2014</div><div class="post-content"><p>作为一个处理问题的很基础的手段，排序在计算机科学的各个方面广泛应用着——例如在查找算法中，如果我们面对的是有序列的话，那么用二分查找我们就倍感顺利、快速，而要获得有序列，首先就得对待查找序列进行排序；又例如，在操作系统的内存管理机制中，内存分配存在<a href="http://thumbsup2life.blogspot.com/2011/02/best-fit-first-fit-and-worst-fit-memory.html" target="_blank" rel="external">许多策略</a>，其中一种被称作 First Fit——遍历可用内存，找到第一个大于等于所需内存大小的内存块，在这块内存块中分配所需内存供使用——而为了让遍历的过程更为快速，或者说降低 First Fit 分配策略实现的时间复杂度，我们可以维护一个按可用内存块大小进行降序排序的内存块索引表，当我们分配内存时便总是可以在索引表中第一位得到最大的可用内存块的地址，从而减少遍历时间，而为了维护这个降序的可用内存索引表，在内存的分配的过程中就必须对内存索引表进行以内存大小为主键的排序操作；再例如，在一些 web 后端程序的页面 cache 机制实现中，我们会按照自己的计算标准对各个页面记录下热度，进而让热度高的页面能够被优先缓存到资源有限的 cache 服务器内存中，为了维护这个表，我们就必须定期对该表进行以页面热度为主键进行降序排序操作。类似的例子，常见的、不常见的还有很多。可以说，排序基本上被应用在软件开发的各个层级、领域。</p>
<a id="more"></a>
<p>因为排序在工程实践中是如此重要，优秀的科学家、工程师们发明了许许多多适合于不同场景的<a href="http://en.wikipedia.org/wiki/Sorting_algorithm#Popular_sorting_algorithmsx`x" target="_blank" rel="external">排序算法</a>。<a href="http://en.wikipedia.org/wiki/Tony_Hoare" target="_blank" rel="external">Tony Hoare</a> 发明的<a href="http://en.wikipedia.org/wiki/Quicksort" target="_blank" rel="external">快速排序</a>是其中最有名、应用最广、在面试过程中最经常被考察到的排序算法之一。</p>
<h2 id="快速排序使用了分治法"><a href="#快速排序使用了分治法" class="headerlink" title="快速排序使用了分治法"></a>快速排序使用了分治法</h2><p>维基百科上的这幅动图很形象地展示了一次快速排序的执行过程：</p>
<img src="http://o9fv3ui6e.bkt.clouddn.com/d9bf49a6-3ca7-11e6-9c0d-93901e77bd33.gif" class="center" width="600">
<p>根据该图，我们可以这样描述快速排序算法的策略：将大问题划分为小问题，而且保证问题的需求以及问题被解决的手段是对于各个问题而言是相同的，这样一来就可以用相同的方式求解各个子问题，等我们解决了所有子问题后，子问题解的组合就是母问题的解。这就是<a href="http://en.wikipedia.org/wiki/Divide_and_conquer_algorithms" target="_blank" rel="external">分治法</a>。</p>
<h2 id="快速排序利用分解数组来达到排序的目的"><a href="#快速排序利用分解数组来达到排序的目的" class="headerlink" title="快速排序利用分解数组来达到排序的目的"></a>快速排序利用分解数组来达到排序的目的</h2><p>当面对一个需要被排序的乱序数组时，我们可以用下面的形式递归地把它分解为一级级的子数组：</p>
<blockquote>
<p>(比基准数小的数组成的<strong>前部数组</strong>)(<strong>基准数</strong>)(比基准数大的数组成的<strong>后部数组</strong>)</p>
</blockquote>
<p>上面的基准数是指按照一定的方式从被分解数组中选出来的某个元素（基准数的挑选是一个很有意思的话题，它直接影响到快排实现的效率，相关讨论见<a href="http://stackoverflow.com/questions/164163/quicksort-choosing-the-pivot" target="_blank" rel="external">一</a>、<a href="http://en.wikipedia.org/wiki/Quicksort#Selection-based_pivoting" target="_blank" rel="external">二</a>）。快速排序利用上述结构来分解数组进而达到了排序的目的，然而具体的分解步骤是怎样的呢？用下面的例子可以进一步阐释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">Array: [1, 5, 2, 7, 6, 15, 20, 10, 9, 11, 8]</span><br><span class="line"></span><br><span class="line">① 第一次分解</span><br><span class="line">    [</span><br><span class="line">        ([1, 5, 2, 7, 6]) //小于基准数的元素在其前形成了前部数组，元素之间的顺序没有改变</span><br><span class="line">        ([8]) //选择最后的元素 8 为基准数</span><br><span class="line">        ([15, 20, 10, 9, 11]) //大于基准数的元素在其后形成了后部数组，元素之间的顺序没有改变</span><br><span class="line">    ]  </span><br><span class="line">② 再按照上一步的分解方式对前部、后部数组进行分解</span><br><span class="line">    [</span><br><span class="line">        ([</span><br><span class="line">            ([1, 5, 2]) //这个数组还不是只含两个或两个以下元素的原子数组，可以继续分解</span><br><span class="line">            ([6])</span><br><span class="line">            ([7])</span><br><span class="line">        ])</span><br><span class="line">        ([8])</span><br><span class="line">        ([</span><br><span class="line">            ([10, 9]) //已经被分解为只含两个元素的数组，选择 2 为基准数再操作一次得到的就是有序排列了</span><br><span class="line">            ([11])</span><br><span class="line">            ([15, 20])</span><br><span class="line">        ])</span><br><span class="line">    ]</span><br><span class="line">③ 至此所有数组都是原子数组了，而且元素的排列已经是有序的了</span><br><span class="line">    [</span><br><span class="line">        ([</span><br><span class="line">            ([</span><br><span class="line">                ([1])</span><br><span class="line">                ([2])</span><br><span class="line">                ([5])</span><br><span class="line">            ])</span><br><span class="line">            ([6])</span><br><span class="line">            ([7])</span><br><span class="line">        ])</span><br><span class="line">        ([8])</span><br><span class="line">        ([</span><br><span class="line">            ([</span><br><span class="line">                ([])</span><br><span class="line">                ([9])</span><br><span class="line">                ([10])</span><br><span class="line">            ])</span><br><span class="line">            ([11])</span><br><span class="line">            ([</span><br><span class="line">                ([15])</span><br><span class="line">                ([20])</span><br><span class="line">                ([])</span><br><span class="line">            ])</span><br><span class="line">        ])</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure>
<p>从上面的例子我们不难理解数组分解的具体步骤：</p>
<ol>
<li>选取一个基准数；</li>
<li>将数组的元素进行移动，大于基准数的放其前面，小于基准数的放其后面——这样就形成了前部子数组以及后部子数组。前部的所有元素都小于基准数，后部的所有元素都大于基准数；</li>
<li>在新获得的前部、后部数组上重复 1、2 步骤；</li>
<li>当数组被分解为最小数组时，选取基准数后分解数组再合并前部、基准数、后部，其结果本身就是有序的了。</li>
</ol>
<p>一个需要额外解释的概念是原子数组：当一个数组只含有两个以及两个以下的元素时，对其按照基准数进行分解操作后，获得的结果一定是有序的，这样的数组被称为原子数组。<strong>当然，这个概念并没有哪个权威教材有介绍，是我为了加强理解创造的。</strong>下面是一个原子数组的分解过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Origin: [5, 4]</span><br><span class="line">① -&gt; 分解完后整个元素的排列就是有序的了</span><br><span class="line">    [([])([4])([5])]</span><br></pre></td></tr></table></figure>
<p>当数组被分解到原子数组的粒度后，我们再逐层合并结果，最后得到的总合并结果就是原数组元素组成的有序数组了，至此则算法结束。</p>
<p>##具体实现</p>
<p>下面是一份来自于维基百科的快速排序的 C 语言实现，它是利用递归来实现的数组分解过程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = data[left]; <span class="comment">//选取数组的最左边元素作为基准数</span></span><br><span class="line">        <span class="keyword">int</span> ptr = left;</span><br><span class="line">        <span class="keyword">int</span> i = left + <span class="number">1</span>, j = right;</span><br><span class="line">        <span class="keyword">if</span>(data[i] &lt;= temp)</span><br><span class="line">        &#123;</span><br><span class="line">                data[ptr] = data[i];</span><br><span class="line">                ptr = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i!=j)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">if</span>(data[j] &gt;= temp)</span><br><span class="line">                &#123;</span><br><span class="line">                        j--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                        data[ptr] = data[j];</span><br><span class="line">                        ptr = j;</span><br><span class="line">                        <span class="keyword">while</span>(data[i] &lt;= temp &amp;&amp; i != j)</span><br><span class="line">                        &#123;</span><br><span class="line">                                i++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        data[ptr] = data[i];</span><br><span class="line">                        ptr = i;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        data[ptr] = temp;</span><br><span class="line">        <span class="keyword">if</span>(left &lt; ptr - <span class="number">1</span>)</span><br><span class="line">                quickSort(data, left, ptr - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ptr + <span class="number">1</span> &lt; right)</span><br><span class="line">                quickSort(data, ptr + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我记得有一个“都市传说”，是说 90% 的程序员无法在没有辅助信息的情况下徒手写出一个完全没有错误的快速排序，大家可以尝试一下。</p>
<p>##进一步讨论</p>
<p>我们继续在一个更有意思的层面上讨论一下快速排序算法——快排和二叉排序树的关系。在快速排序的算法中，利用分治法的思想，我们将大问题（对无序数组排序）分解为了一个二叉树形的问题。这个过程用语言描述不是很方便，我们用图来解释。</p>
<p>第一次进行问题转化，选出基（准）数，并将问题分解为了子问题 1 和子问题 2：</p>
<img src="http://o9fv3ui6e.bkt.clouddn.com/f1489bfe-3ca7-11e6-bcc9-0ff48e4bbf9f.jpg" class="center" width="600">
<p>第二次，在子问题上进行进一步的相同操作则会形成如下的问题结构：</p>
<img src="http://o9fv3ui6e.bkt.clouddn.com/f8ab6dea-3ca7-11e6-85df-afdea4e09b83.jpg" class="center" width="600">
<p>继续下去，你就会发现，其实原始问题被划分为了一个二叉树形的结构——很完美的是，它甚至还是一个满的完全二叉树。</p>
<p>我们以数组 [2，5，3，6，1，10，9，7，8，4] 为例子，选取最后一个数字为基（准）数。按照之前的算法进行操作，最后我们得到了如下结构：</p>
<img src="http://o9fv3ui6e.bkt.clouddn.com/ff14c988-3ca7-11e6-8398-17e607d17a64.jpg" class="center" width="600">
<p>这其实本身就是一棵二叉查找树。也就是说，通过快速排序的分治以及递归的处理之后，基（准）数之间存在一个父基数以及子基（准）数的关系，而这个关系结合基（准）数本身的值构成了一个二叉查找树。与其说快排之后我们按照数列的下标进行遍历就得到了排序好的序列，不如说我们按照基（准）数组成的二叉查找树进行了一次按中序进行的遍历——而二叉查找树的中序遍历结果就是有序结果。</p>
<p>##备注</p>
<p>这篇文章最早是我在 2011 年写完，并发布于当时的<a href="http://blog.csdn.net/nieweilin/article/details/6939888" target="_blank" rel="external">博客</a>上的。我对其内容进行修改、添加，形成了此文。</p>
</div></article></div></section><footer><div class="paginator"><a href="/2014/12/27/let-us-talk-about-objc-properties/" class="prev">PREV</a><a href="/2014/12/15/when-will-layoutsubviews-be-invoked/" class="next">NEXT</a></div><div data-thread-key="2014/12/26/some-thoughts-on-quicksort/" data-title="关于快速排序算法的一些想法" data-url="http://bachiscoding.com/2014/12/26/some-thoughts-on-quicksort/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"bachiscoding"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2015 - 2016 <a href="http://bachiscoding.com">winiex</a>, unless otherwise noted.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>