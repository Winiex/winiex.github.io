<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 关于 UIView 的 layoutSubviews 方法 · Bach is coding</title><meta name="description" content="关于 UIView 的 layoutSubviews 方法 - winiex"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">HOME</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/winiex" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">关于 UIView 的 layoutSubviews 方法</h1><div class="post-info">Dec 15, 2014</div><div class="post-content"><p>UIKit 的 UIView 是一个非常重要的类，几乎每个尝试 iOS 开发的程序员都会用到它。UIView 本身实现了 <a href="http://en.wikipedia.org/wiki/Composite_pattern" target="_blank" rel="external">Composite Pattern</a>，所以一个应用的界面最终可以由一群树状组合的 UIView 来组合而成——在这棵 UIView 树的最顶部，是继承于 UIView 的 UIWindow 实例，然后是由 UIWindow 实例保有的 rootViewController 的根 UIView 实例，然后是在该 UIView 实例上的各种各样的子节点 UIView。</p>
<a id="more"></a>
<p>父 UIView 可以拥有自己的子 UIView，自然而然的，父 UIView 就会面对用怎样的策略来布局、排列这些子 UIView 的问题。在 UIView 中，UIKit 的开发者专门提供了 <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/index.html#//apple_ref/occ/instm/UIView/layoutSubviews" target="_blank" rel="external">layoutSubviews</a> 方法来解决这个问题。</p>
<h2 id="官方文档的描述"><a href="#官方文档的描述" class="headerlink" title="官方文档的描述"></a>官方文档的描述</h2><p>官方文档对于该方法有如下的描述：</p>
<blockquote>
<p>(This method) Lays out subviews.</p>
<p>Subclasses can override this method as needed to perform more precise layout of their subviews. <strong>You should override this method only if the autoresizing and constraint-based behaviors of the subviews DO NOT offer the behavior you want</strong>. You can use your implementation to set the frame rectangles of your subviews directly.</p>
<p><em>以上节选自 <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/index.html" target="_blank" rel="external">UIView Class Reference</a></em></p>
<p>Whenever the size of a view changes, UIKit applies the autoresizing behaviors of that view’s subviews and <strong>THEN</strong> calls the layoutSubviews method of the view to let it make manual changes. You can implement the layoutSubviews method in custom views when the autoresizing behaviors by themselves <strong>DO NOT</strong> yield the results you want. Your implementation of this method can do any of the following:</p>
<ol>
<li><strong>Adjust the size and position of any immediate subviews.</strong></li>
<li>Add or remove subviews or Core Animation layers.</li>
<li>Force a subview to be redrawn by calling its setNeedsDisplay or setNeedsDisplayInRect: method.</li>
</ol>
<p>One place where applications often lay out subviews manually is when implementing a large scrollable area. Because it is impractical to have a single large view for its scrollable content, applications often implement a root view that contains a number of smaller tile views. Each tile represents a portion of the scrollable content. When a scroll event happens, the root view calls its setNeedsLayout method to initiate a layout change. Its layoutSubviews method then repositions the tile views based on the amount of scrolling that occurred. As tiles scroll out of the view’s visible area, the layoutSubviews method moves the tiles to the incoming edge, replacing their contents in the process.</p>
<p><em>以上节选自 <a href="https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/ViewPG_iPhoneOS/CreatingViews/CreatingViews.html" target="_blank" rel="external">View Programming Guide for iOS</a></em></p>
</blockquote>
<p>从文档的描述可以看到，layoutSubviews 的主要功能就是让程序员自己实现子 UIViews 的布局算法，从而在需要重新布局的时候，父 UIView 会按照这个流程重新布局自己的子 UIViews。<strong>而且，layoutSubviews 方法只能被系统触发调用，程序员不能手动直接调用该方法。</strong>要引起该方法的调用，可以调用 UIView 的 <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/index.html#//apple_ref/occ/instm/UIView/setNeedsLayout" target="_blank" rel="external">setNeedsLayout</a> 方法来标记一个 UIView。这样一来，在 UI 线程的下次绘制循环中，系统便会调用该 UIView 的 layoutSubviews 方法。</p>
<h2 id="使用-layoutSubviews-的实例"><a href="#使用-layoutSubviews-的实例" class="headerlink" title="使用 layoutSubviews 的实例"></a>使用 layoutSubviews 的实例</h2><p>一个比较典型的例子来自于 <a href="https://github.com/robbdimitrov/RDVTabBarController" target="_blank" rel="external">RDVTabBarController</a> 项目，它的目标是实现一个提供高定制性的 TabBarController。在这个项目中，作者使用了 layoutSubviews 来控制 TabBar 的子 UIView——TabBarItem 的重新布局，从而达到 TabBar 发生变化时 TabBarItem 的绘制与布局不会出错的目的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)layoutSubviews &#123;</span><br><span class="line">    <span class="comment">//在调用 UIView 的 layoutSubviews 方法之前，UIView 的 frame 已经更新了，下面的 frameSize 就是最新的 frame 的 size 属性</span></span><br><span class="line">    <span class="built_in">CGSize</span> frameSize = <span class="keyword">self</span>.frame.size;</span><br><span class="line">    <span class="built_in">CGFloat</span> minimumContentHeight = [<span class="keyword">self</span> minimumContentHeight];</span><br><span class="line"></span><br><span class="line">    [[<span class="keyword">self</span> backgroundView] setFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, frameSize.height - minimumContentHeight,</span><br><span class="line">                                            frameSize.width, frameSize.height)];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据新的 TabBar 的 frameSize 来计算每个 TabBarItem 的新宽度，进而保证在绘制后不会TabBarItem 的宽度超出 TabBar 等问题</span></span><br><span class="line">    [<span class="keyword">self</span> setItemWidth:roundf((frameSize.width - [<span class="keyword">self</span> contentEdgeInsets].left -</span><br><span class="line">                               [<span class="keyword">self</span> contentEdgeInsets].right) / [[<span class="keyword">self</span> items] count])];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSInteger</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Layout items</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (RDVTabBarItem *item <span class="keyword">in</span> [<span class="keyword">self</span> items]) &#123;</span><br><span class="line">        <span class="built_in">CGFloat</span> itemHeight = [item itemHeight];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!itemHeight) &#123;</span><br><span class="line">            itemHeight = frameSize.height;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据最新计算出来的宽、高来设置 TabBarItem 的 frame 属性。</span></span><br><span class="line">        <span class="comment">//设置 frame 属性后，如果新设置的 frame 不同于设置之前的 frame，系统会自动调用该 UIView 的 layoutSubviews 方法来重新布局</span></span><br><span class="line">        [item setFrame:<span class="built_in">CGRectMake</span>(<span class="keyword">self</span>.contentEdgeInsets.left + (index * <span class="keyword">self</span>.itemWidth),</span><br><span class="line">                                  roundf(frameSize.height - itemHeight) - <span class="keyword">self</span>.contentEdgeInsets.top,</span><br><span class="line">                                  <span class="keyword">self</span>.itemWidth, itemHeight - <span class="keyword">self</span>.contentEdgeInsets.bottom)];</span><br><span class="line">        <span class="comment">//设置新的 frame 不会引起 UIView 的重绘，所以需要手工强制其重绘</span></span><br><span class="line">        [item setNeedsDisplay];</span><br><span class="line"></span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我在代码中的注释解释了这段代码都做了什么。如果你要实现自己的 layoutSubviews 方法的话，可以参考这个例子的流程。</p>
<h2 id="何时被调用"><a href="#何时被调用" class="headerlink" title="何时被调用"></a>何时被调用</h2><p>一个曾经让我比较疑惑的问题是，既然我不能手动直接调用该方法，那在什么时候、何种条件下这个方法会被调用呢？</p>
<p>Stackoverflow 上已经有<a href="http://stackoverflow.com/questions/728372/when-is-layoutsubviews-called" target="_blank" rel="external">相关的讨论</a>了（作者在他的<a href="http://blog.logichigh.com/2011/03/16/when-does-layoutsubviews-get-called/" target="_blank" rel="external">博客</a>上有更详细的描述），并且有一位朋友给出了很不错的解答：</p>
<blockquote>
<ol>
<li>init does not cause layoutSubviews to be called (duh)</li>
<li>addSubview causes layoutSubviews to be called on the view being added, the view it’s being added to (target view), and all the subviews of the target</li>
<li>view setFrame intelligently calls layoutSubviews on the view having its frame set only if the size parameter of the frame is different</li>
<li>scrolling a UIScrollView causes layoutSubviews to be called on the scrollView, and its superview</li>
<li>rotating a device only calls layoutSubview on the parent view (the responding viewControllers primary view)</li>
<li>Resizing a view will call layoutSubviews on its superview</li>
</ol>
</blockquote>
<p>也就是说，layoutSubviews 方法会在这些情况下，在这些 UIView 实例上被调用：</p>
<ol>
<li>addSubview 被调用时：target view（一定会），以及被添加的 view（第一次调用会）</li>
<li>更改 UIView 的 frame 时：被更改 frame 的 view（frame 与之前不同时）</li>
<li>对于 UIScrollView 而言，滚动式：scroll view</li>
<li>设备的 orientation 改变时：涉及改变的 UIViewController 的 root view</li>
<li>使用 CGAffineTransformScale 改变 view 的 transform 属性时，view 的 superview：被改变的 view</li>
</ol>
<p>然而，根据我自己的实验，上面的描述并不是很完善的。我的两点补充如下：</p>
<ol>
<li>第一次调用 addSubview 的时候，target view 和被添加到 target view 的 view 的 layoutSubviews 方法会被调用。在已经添加完毕后，若 target view 已经拥有该被添加 view，则只有 target view 的 layoutSubviews 方法会被调用。“and all the subviews of the target”这句话是错误的。</li>
<li>只有 UIView 处于 key window 的 UIView 树中时，该 UIView 的 layoutSubviews 方法才有可能被调用。不在树中的不会被调用。这也是为什么 Stackoverflow 上的讨论中<a href="http://stackoverflow.com/a/13121202/1516652" target="_blank" rel="external">这个答案</a>的第二点会被提出。</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>使用 layoutSubviews 可以让应用界面的适应能力更强。如果 UIKit 默认提供的自动布局机制 <a href="https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/AutolayoutPG/Introduction/Introduction.html" target="_blank" rel="external">Auto Layout</a> 不能提供给你想要的 UIView 布局行为，你可以自己定制该方法来决定布局行为。</p>
</div></article></div></section><footer><div class="paginator"><a href="/2014/12/26/some-thoughts-on-quicksort/" class="prev">上一篇</a><a href="/2014/11/11/relationship-between-anchor-point-and-position-property-of-calayer/" class="next">下一篇</a></div><div data-thread-key="2014/12/15/when-will-layoutsubviews-be-invoked/" data-title="关于 UIView 的 layoutSubviews 方法" data-url="http://bachiscoding.com/2014/12/15/when-will-layoutsubviews-be-invoked/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"bachiscoding"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2015 - 2016 <a href="http://bachiscoding.com">winiex</a>, unless otherwise noted.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>