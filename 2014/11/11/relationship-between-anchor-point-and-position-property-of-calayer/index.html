<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> CALayer 的 position 属性与 anchorPoint 属性间的关系 · Bach is coding</title><meta name="description" content="CALayer 的 position 属性与 anchorPoint 属性间的关系 - winiex"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/winiex" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">CALayer 的 position 属性与 anchorPoint 属性间的关系</h1><div class="post-info">Nov 11, 2014</div><div class="post-content"><p>因为最近在制作自己的独立产品，我学习了一些 iOS 平台的知识。在我的产品界面中，有一个侧边栏需要单独绘制自定义外观，所以这几天我就研究了一下 UIView 的绘制机理以及 Core Animation 中 CALayer 的相关的知识。在 CALayer 中有一个我比较困惑的地方：position 和 anchorPoint 之间的关系，以及它们对于动画、UIView 绘制的过程会作出何种影响。在看了一遍官方文档，搜索了一些相关博客文章、帖子后，我有了较为完整的理解。</p>
<a id="more"></a>
<h2 id="position、anchorPoint-的定义及属性"><a href="#position、anchorPoint-的定义及属性" class="headerlink" title="position、anchorPoint 的定义及属性"></a>position、anchorPoint 的定义及属性</h2><p>要理解这两个属性，首先要理解 CALayer 中的坐标体系。在 CALayer 系统中，存在两种形式的坐标体系——基于 Point 的和基于 Unit 的：</p>
<blockquote>
<p>Point-based coordinates: Point-based coordinates are used when specifying values that map <strong>directly to screen coordinates</strong> or must be specified relative to another layer.<br><br><br>Unit-based coordinates: Unit coordinates are used when the value should not be tied to screen coordinates because it is relative to some other value. For example, the layer’s anchorPoint property specifies a point relative to the bounds of the layer itself, which can change. You can think of the unit coordinates as specifying <strong>a percentage of the total possible value</strong>. Every coordinate in the unit coordinate space has a range of 0.0 to 1.0. For example, along the x-axis, the left edge is at the coordinate 0.0 and the right edge is at the coordinate 1.0.</p>
</blockquote>
<p>Point-based coordinates 实际上就是 UIView 中的 bounds、center、frame 使用的坐标体系。Unit-based coordinates 中的坐标点、长度会根据屏幕、设备的不同，对应到不同的 Point-based coordinates 中的坐标点、长度。</p>
<p>下面正式介绍 position 和 anchorPoint。根据苹果的官方文档的描述，它们的定义如下：</p>
<blockquote>
<p>The position property defines the location of the layer <strong>relative to its parent’s coordinate system</strong>.<br><br><br>The anchor point represents the point from which certain coordinates <strong>originate</strong>.</p>
</blockquote>
<p>本质上，position 和 anchorPoint 都是其所属的 layer 上的<strong>同一个点</strong>，在 layer 上、以及 layer 所属的 UIView 对象上进行的动画会围绕该点进行。它们都是 CAPoint 对象，拥有 x、y 属性来表达不同轴上的位置。不同的地方在于，position 是基于 Point 单位，相对于 layer 的 super layer 的 bounds 来定义的；而 anchorPoint 则是基于 Unit 单位，相对于 layer 本身的 bounds 来定义的。尽管坐标单位和相对坐标系不一样，position 和 anchorPoint <strong>最终</strong>都在屏幕上代表着同一个点。“最终一致”的意思是说，如果在下一次重绘之前，它们的属性被改变了的话，那么在重绘之后，layer 会被系统重新绘制调整位置后，保证它们还是在屏幕上的同样的一个点。之所以系统能够保证这一点，是因为系统可以调整 layer 的 frame.origin，从而保证在调整后，根据新的 frame.origin 配合 anchorPoint 计算出来的在 super layer bounds 中的点和 position 是一样的。</p>
<p>在默认情况下，独立的 CALayer 对象的 position 是 (0.0, 0.0)，这点在 Apple 的 <a href="https://developer.apple.com/LIBRARY/ios/documentation/GraphicsImaging/Reference/CALayer_class/index.html#//apple_ref/occ/instp/CALayer/position" target="_blank" rel="external">CALayer Reference</a> 中有提到：</p>
<blockquote>
<p>For new <strong>standalone</strong> layers, the default position is set to (0.0, 0.0).</p>
</blockquote>
<p>独立的意思是说，该 CALayer 对象不从属于任何 UIView 对象。CALayer 对象的 anchorPoint 会被初始化为 (0.5, 0.5)。在从属于 UIView 对象的 CALayer 对象中，position 也会根据该 anchorPoint 计算出来的自己相应的值，而不再是 (0.0, 0.0)：</p>
<blockquote>
<p>The default value of this property (anchorPoint) is (0.5, 0.5), which represents the <strong>center</strong> of the layer’s bounds rectangle.</p>
</blockquote>
<p>下面的代码段可以证明我的观点：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CALayer</span> *standaloneLayer = [[<span class="built_in">CALayer</span> alloc] init];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"Standalone layer's position: x is %f, y is %f."</span>, standaloneLayer.position.x, standaloneLayer.position.y);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"Standalone layer's anchorPoint: x is %f, y is %f."</span>, standaloneLayer.anchorPoint.x, standaloneLayer.anchorPoint.y);</span><br><span class="line"></span><br><span class="line"><span class="built_in">UIView</span> *view = [[<span class="built_in">UIView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>)];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"View's layer's position: x is %f, y is %f."</span>, view.layer.position.x, view.layer.position.y);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"View's layer's anchorPoint: x is %f, y is %f."</span>, view.layer.anchorPoint.x, view.layer.anchorPoint.y);</span><br></pre></td></tr></table></figure>
<p>上述代码执行后的输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Standalone layer&apos;s position: x is 0.000000, y is 0.000000.</span><br><span class="line">Standalone layer&apos;s anchorPoint: x is 0.500000, y is 0.500000.</span><br><span class="line"></span><br><span class="line">View&apos;s layer&apos;s position: x is 100.000000, y is 100.000000.</span><br><span class="line">View&apos;s layer&apos;s anchorPoint: x is 0.500000, y is 0.500000.</span><br></pre></td></tr></table></figure>
<h2 id="position-和-anchorPoint-的关系"><a href="#position-和-anchorPoint-的关系" class="headerlink" title="position 和 anchorPoint 的关系"></a>position 和 anchorPoint 的关系</h2><p>改变 position 或 anchorPoint 都不会影响到另一方，但是都会影响其所属 layer 的 frame.origin 属性。这个设计尽管比较奇怪，但是却最终能够保证 position 和 anchorPoint 的一致性。</p>
<p>根据<a href="http://wonderffee.github.io/blog/2013/10/13/understand-anchorpoint-and-position/" target="_blank" rel="external">彻底理解 position 与 anchorPoint</a> 这篇文章的观点，我们可以知道这三个属性之间的计算关系如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">frame.origin.x = position.x - anchorPoint.x * bounds.size.width；  </span><br><span class="line">frame.origin.y = position.y - anchorPoint.y * bounds.size.height；</span><br></pre></td></tr></table></figure>
<p>在每次修改 position 或者 anchorPoint 后，系统都会根据上述公式来变更 CALayer 对象的 frame.origin，以保证两个属性的一致性。下面的代码段可以佐证我的观点：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIView</span> *view = [[<span class="built_in">UIView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>)];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"View's layer's frame.origin: x is %f, y is %f."</span>, view.layer.frame.origin.x, view.layer.frame.origin.y);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"View's layer's position: x is %f, y is %f."</span>, view.layer.position.x, view.layer.position.y);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"View's layer's anchorPoint: x is %f, y is %f."</span>, view.layer.anchorPoint.x, view.layer.anchorPoint.y);</span><br><span class="line"></span><br><span class="line">view.layer.anchorPoint = <span class="built_in">CGPointMake</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"View's layer's frame.origin: x is %f, y is %f."</span>, view.layer.frame.origin.x, view.layer.frame.origin.y);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"View's layer's position: x is %f, y is %f."</span>, view.layer.position.x, view.layer.position.y);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"View's layer's anchorPoint: x is %f, y is %f."</span>, view.layer.anchorPoint.x, view.layer.anchorPoint.y);</span><br><span class="line"></span><br><span class="line">view.layer.position = <span class="built_in">CGPointMake</span>(<span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"View's layer's frame.origin: x is %f, y is %f."</span>, view.layer.frame.origin.x, view.layer.frame.origin.y);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"View's layer's position: x is %f, y is %f."</span>, view.layer.position.x, view.layer.position.y);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"View's layer's anchorPoint: x is %f, y is %f."</span>, view.layer.anchorPoint.x, view.layer.anchorPoint.y);</span><br></pre></td></tr></table></figure>
<p>上述代码段的输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">View&apos;s layer&apos;s frame.origin: x is 0.000000, y is 0.000000.</span><br><span class="line">View&apos;s layer&apos;s position: x is 100.000000, y is 100.000000.</span><br><span class="line">View&apos;s layer&apos;s anchorPoint: x is 0.500000, y is 0.500000.</span><br><span class="line"></span><br><span class="line">View&apos;s layer&apos;s frame.origin: x is 100.000000, y is 100.000000.</span><br><span class="line">View&apos;s layer&apos;s position: x is 100.000000, y is 100.000000.</span><br><span class="line">View&apos;s layer&apos;s anchorPoint: x is 0.000000, y is 0.000000.</span><br><span class="line"></span><br><span class="line">View&apos;s layer&apos;s frame.origin: x is 50.000000, y is 50.000000.</span><br><span class="line">View&apos;s layer&apos;s position: x is 50.000000, y is 50.000000.</span><br><span class="line">View&apos;s layer&apos;s anchorPoint: x is 0.000000, y is 0.000000.</span><br></pre></td></tr></table></figure>
<p>我们可以看到在上述代码执行的过程中，position 和 anchorPoint 都没有被系统改变，只有 frame.origin 被系统所改变。而且，在 frame.origin 改变后，position 和 anchorPoint 在 super layer 的坐标系中又重新指代同一个点了。</p>
<h2 id="更直观的例子"><a href="#更直观的例子" class="headerlink" title="更直观的例子"></a>更直观的例子</h2><p>进一步地，我们可以在更形象的例子中去展示这个过程。</p>
<p>下面这个例子演示了一个绿色 UIView 被缩放的过程。在这个例子中，我们可以看到，动画发生的位置总是围绕着 anchorPoint/position 进行，而且系统会在绘制的过程中保证最终两点的重合——这表现为，在动画发生前绿色方块的位置被重置了。例子的运行效果如下：</p>
<img src="http://o9fv3ui6e.bkt.clouddn.com/9c882dbe-3ca7-11e6-a4e4-9303687b734a.gif" class="center" width="600">
<p>例子的代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  ViewController.m</span></span><br><span class="line"><span class="comment">//  FacebookPopPlay</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by winiex on 14/11/10.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2014年 winiex. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIView</span> *greenView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.greenView = [[<span class="built_in">UIView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">180</span>, <span class="number">180</span>)];</span><br><span class="line">    <span class="keyword">self</span>.greenView.backgroundColor = [<span class="built_in">UIColor</span> greenColor];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//点击一次后，动画开始</span></span><br><span class="line">    <span class="built_in">UITapGestureRecognizer</span> *recognizer = [[<span class="built_in">UITapGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(onTapOnce)];</span><br><span class="line">    recognizer.numberOfTapsRequired = <span class="number">1</span>;</span><br><span class="line">    [<span class="keyword">self</span>.greenView addGestureRecognizer:recognizer];</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.greenView];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)onTapOnce &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"anchorPoint: x is %f, y is %f"</span>, <span class="keyword">self</span>.greenView.layer.anchorPoint.x, <span class="keyword">self</span>.greenView.layer.anchorPoint.y);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"position: x is %f, y is %f"</span>, <span class="keyword">self</span>.greenView.layer.position.x, <span class="keyword">self</span>.greenView.layer.position.y);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"frame.origin: x is %f, y is %f"</span>, <span class="keyword">self</span>.greenView.layer.frame.origin.x, <span class="keyword">self</span>.greenView.layer.frame.origin.y);</span><br><span class="line">    <span class="comment">//动画执行的相关代码</span></span><br><span class="line">    <span class="keyword">self</span>.greenView.layer.anchorPoint = <span class="built_in">CGPointMake</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果加上下面这行代码的话，greenView 就不会在动画开始前“跳跃了”</span></span><br><span class="line">    <span class="comment">//self.greenView.layer.position = CGPointMake(100, 100);</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"anchorPoint: x is %f, y is %f"</span>, <span class="keyword">self</span>.greenView.layer.anchorPoint.x, <span class="keyword">self</span>.greenView.layer.anchorPoint.y);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"position: x is %f, y is %f"</span>, <span class="keyword">self</span>.greenView.layer.position.x, <span class="keyword">self</span>.greenView.layer.position.y);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"frame.origin: x is %f, y is %f"</span>, <span class="keyword">self</span>.greenView.layer.frame.origin.x, <span class="keyword">self</span>.greenView.layer.frame.origin.y);</span><br><span class="line"></span><br><span class="line">    [<span class="built_in">UIView</span> animateWithDuration:<span class="number">2</span> delay:<span class="number">0</span> options:<span class="built_in">UIViewAnimationOptionCurveEaseOut</span> animations:^&#123;</span><br><span class="line">        <span class="keyword">self</span>.greenView.transform = <span class="built_in">CGAffineTransformMakeScale</span>(<span class="number">0.1</span>, <span class="number">0.1</span>);</span><br><span class="line">    &#125; completion:^(<span class="built_in">BOOL</span> finished) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>例子的控制台输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">anchorPoint: x is 0.500000, y is 0.500000</span><br><span class="line">position: x is 190.000000, y is 190.000000</span><br><span class="line">frame.origin: x is 100.000000, y is 100.000000</span><br><span class="line">anchorPoint: x is 0.000000, y is 0.000000</span><br><span class="line">position: x is 190.000000, y is 190.000000</span><br><span class="line">frame.origin: x is 190.000000, y is 190.000000</span><br></pre></td></tr></table></figure>
<p>当我们加上“self.greenView.layer.position = CGPointMake(100, 100);”这一行代码后，例子最终运行的效果如下：</p>
<img src="http://o9fv3ui6e.bkt.clouddn.com/a894d5c6-3ca7-11e6-be22-1be1d908e938.gif" class="center" width="600">
<p>动画的效果一下子变的自然了。而且，很明显，绿色方块的形变是根据新的 anchorPoint/position 在进行。</p>
<h2 id="小问题"><a href="#小问题" class="headerlink" title="小问题"></a>小问题</h2><p>在下图中，黑块是绿块的 sublayer，长、宽都是绿块的 1/4，其 position 处在绿块的正中心。怎样调整黑块的 anchorPoint 来完成下图的布局呢？</p>
<img src="http://o9fv3ui6e.bkt.clouddn.com/b034b2d8-3ca7-11e6-b22e-a76808f58d3b.jpg" class="center" width="600">
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>根据前文的描述，对于 CALayer 对象的 position 和 anchorPoint 的相关知识总结如下：</p>
<ol>
<li>position 和 anchorPoint 都是其所属的 layer 上的同一个点；</li>
<li>position 针对 CALayer 对象的 super layer 而言，anchorPoint 针对 CALayer 对象本身而言；</li>
<li>position 使用基于 Point 的坐标系，anchorPoint 使用基于 Unit 的坐标系；</li>
<li>系统通过变更 CALayer 对象的 frame.origin 来保证 position 与 anchorPoint 为同一个点。</li>
</ol>
</div></article></div></section><footer><div class="paginator"><a href="/2014/12/15/when-will-layoutsubviews-be-invoked/" class="prev">PREV</a><a href="/2014/10/21/the-way-of-becoming-a-newbie-designer/" class="next">NEXT</a></div><div data-thread-key="2014/11/11/relationship-between-anchor-point-and-position-property-of-calayer/" data-title="CALayer 的 position 属性与 anchorPoint 属性间的关系" data-url="http://bachiscoding.com/2014/11/11/relationship-between-anchor-point-and-position-property-of-calayer/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"bachiscoding"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2015 - 2016 <a href="http://bachiscoding.com">winiex</a>, unless otherwise noted.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>